package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"text/template"
)

const goTemplate = `// Code generated by staticerize, DO NOT EDIT.
//
// input parameters: {{.Input}}
package {{.PackageName}}

// generated using staticerize from file {{.SourceFilePath}}
const {{.VariableName}} = ` + "`" + `{{.Data}}` + "`" + `
`

func main() {
	inFile := flag.String("in", "", "the file to read")
	varName := flag.String("var", "", "(optional) the name of the variable that will be created. If not set, the name of the file minus extension will be used")
	outFile := flag.String("out", "", "the output go sourcefile to create. Make sure to set extension to '.go'")
	packageName := flag.String("pkg", "", "the package name this file will be generated as")
	//accessors := flag.String("access", "Const", "comma delimited list of ways to access the data.")
	flag.Parse()
	// if err != nil {
	// 	flag.PrintDefaults()
	// 	os.Exit(1)
	// }

	if *inFile == "" {
		fatal(errors.New("in is required"))
	}
	if *outFile == "" {
		fatal(errors.New("out is required"))
	}
	if *packageName == "" {
		fatal(errors.New("pkg is required"))
	}
	if *varName == "" {
		_, fName := path.Split(*inFile)
		vn := strings.TrimSuffix(fName, path.Ext(fName))
		varName = &vn
	}

	fin, err := os.Open(*inFile)
	if err != nil {
		fatal(err)
	}

	fout, err := os.Create(*outFile)
	if err != nil {
		fatal(err)
	}

	t := template.Must(template.New("cg").Parse(goTemplate))
	type tem struct {
		PackageName    string
		VariableName   string
		Data           string
		Input          string
		SourceFilePath string
	}
	data, err := ioutil.ReadAll(fin)
	if err != nil {
		fatal(err)
	}
	tData := &tem{
		PackageName:    *packageName,
		VariableName:   *varName,
		Data:           string(data),
		Input:          strings.Join(os.Args, " "),
		SourceFilePath: *inFile,
	}
	err = t.Execute(fout, tData)
	if err != nil {
		fatal(err)
	}

}

func fatal(err error) {
	fmt.Fprintf(os.Stderr, "%v", err)
	os.Exit(1)
}
